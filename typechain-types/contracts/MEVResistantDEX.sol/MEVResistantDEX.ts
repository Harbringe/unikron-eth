/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export declare namespace MEVResistantDEX {
  export type SwapRequestStruct = {
    tokenIn: AddressLike;
    tokenOut: AddressLike;
    amountIn: BigNumberish;
    minAmountOut: BigNumberish;
    deadline: BigNumberish;
    salt: BigNumberish;
    slippageBps: BigNumberish;
  };

  export type SwapRequestStructOutput = [
    tokenIn: string,
    tokenOut: string,
    amountIn: bigint,
    minAmountOut: bigint,
    deadline: bigint,
    salt: bigint,
    slippageBps: bigint
  ] & {
    tokenIn: string;
    tokenOut: string;
    amountIn: bigint;
    minAmountOut: bigint;
    deadline: bigint;
    salt: bigint;
    slippageBps: bigint;
  };

  export type OrderStruct = {
    trader: AddressLike;
    tokenIn: AddressLike;
    tokenOut: AddressLike;
    amountIn: BigNumberish;
    minAmountOut: BigNumberish;
    deadline: BigNumberish;
    salt: BigNumberish;
    commitment: BytesLike;
    revealed: boolean;
    executed: boolean;
    commitTimestamp: BigNumberish;
  };

  export type OrderStructOutput = [
    trader: string,
    tokenIn: string,
    tokenOut: string,
    amountIn: bigint,
    minAmountOut: bigint,
    deadline: bigint,
    salt: bigint,
    commitment: string,
    revealed: boolean,
    executed: boolean,
    commitTimestamp: bigint
  ] & {
    trader: string;
    tokenIn: string;
    tokenOut: string;
    amountIn: bigint;
    minAmountOut: bigint;
    deadline: bigint;
    salt: bigint;
    commitment: string;
    revealed: boolean;
    executed: boolean;
    commitTimestamp: bigint;
  };
}

export interface MEVResistantDEXInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "COMMIT_REVEAL_DELAY"
      | "FIXED_FEE_BPS"
      | "MAX_SLIPPAGE_BPS"
      | "MIN_SLIPPAGE_BPS"
      | "authorizedRelayers"
      | "canReveal"
      | "commitOrder"
      | "executeOrderByRelayer"
      | "getOrder"
      | "getUserNonce"
      | "orders"
      | "owner"
      | "rescueETH"
      | "rescueTokens"
      | "revealAndExecute"
      | "setPaused"
      | "setRelayerAuthorization"
      | "uniswapV2Router"
      | "uniswapV3Router"
      | "updateDEXRouters"
      | "userNonces"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "OrderCommitted"
      | "OrderExecuted"
      | "OrderRevealed"
      | "RelayerAuthorized"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "COMMIT_REVEAL_DELAY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FIXED_FEE_BPS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_SLIPPAGE_BPS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_SLIPPAGE_BPS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "authorizedRelayers",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "canReveal",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "commitOrder",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "executeOrderByRelayer",
    values: [BytesLike, MEVResistantDEX.SwapRequestStruct]
  ): string;
  encodeFunctionData(functionFragment: "getOrder", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getUserNonce",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "orders", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rescueETH",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "rescueTokens",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "revealAndExecute",
    values: [BytesLike, MEVResistantDEX.SwapRequestStruct]
  ): string;
  encodeFunctionData(functionFragment: "setPaused", values: [boolean]): string;
  encodeFunctionData(
    functionFragment: "setRelayerAuthorization",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapV2Router",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapV3Router",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateDEXRouters",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "userNonces",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "COMMIT_REVEAL_DELAY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FIXED_FEE_BPS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_SLIPPAGE_BPS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_SLIPPAGE_BPS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "authorizedRelayers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "canReveal", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "commitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeOrderByRelayer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getUserNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "orders", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rescueETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rescueTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealAndExecute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setPaused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setRelayerAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapV2Router",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapV3Router",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateDEXRouters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "userNonces", data: BytesLike): Result;
}

export namespace OrderCommittedEvent {
  export type InputTuple = [
    orderHash: BytesLike,
    trader: AddressLike,
    commitTimestamp: BigNumberish
  ];
  export type OutputTuple = [
    orderHash: string,
    trader: string,
    commitTimestamp: bigint
  ];
  export interface OutputObject {
    orderHash: string;
    trader: string;
    commitTimestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderExecutedEvent {
  export type InputTuple = [
    orderHash: BytesLike,
    trader: AddressLike,
    amountOut: BigNumberish,
    feeCollected: BigNumberish,
    dexUsed: string
  ];
  export type OutputTuple = [
    orderHash: string,
    trader: string,
    amountOut: bigint,
    feeCollected: bigint,
    dexUsed: string
  ];
  export interface OutputObject {
    orderHash: string;
    trader: string;
    amountOut: bigint;
    feeCollected: bigint;
    dexUsed: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderRevealedEvent {
  export type InputTuple = [
    orderHash: BytesLike,
    trader: AddressLike,
    tokenIn: AddressLike,
    tokenOut: AddressLike,
    amountIn: BigNumberish,
    minAmountOut: BigNumberish
  ];
  export type OutputTuple = [
    orderHash: string,
    trader: string,
    tokenIn: string,
    tokenOut: string,
    amountIn: bigint,
    minAmountOut: bigint
  ];
  export interface OutputObject {
    orderHash: string;
    trader: string;
    tokenIn: string;
    tokenOut: string;
    amountIn: bigint;
    minAmountOut: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RelayerAuthorizedEvent {
  export type InputTuple = [relayer: AddressLike, authorized: boolean];
  export type OutputTuple = [relayer: string, authorized: boolean];
  export interface OutputObject {
    relayer: string;
    authorized: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface MEVResistantDEX extends BaseContract {
  connect(runner?: ContractRunner | null): MEVResistantDEX;
  waitForDeployment(): Promise<this>;

  interface: MEVResistantDEXInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  COMMIT_REVEAL_DELAY: TypedContractMethod<[], [bigint], "view">;

  FIXED_FEE_BPS: TypedContractMethod<[], [bigint], "view">;

  MAX_SLIPPAGE_BPS: TypedContractMethod<[], [bigint], "view">;

  MIN_SLIPPAGE_BPS: TypedContractMethod<[], [bigint], "view">;

  authorizedRelayers: TypedContractMethod<
    [arg0: AddressLike],
    [boolean],
    "view"
  >;

  canReveal: TypedContractMethod<[orderHash: BytesLike], [boolean], "view">;

  commitOrder: TypedContractMethod<[commitment: BytesLike], [void], "payable">;

  executeOrderByRelayer: TypedContractMethod<
    [orderHash: BytesLike, swapRequest: MEVResistantDEX.SwapRequestStruct],
    [void],
    "nonpayable"
  >;

  getOrder: TypedContractMethod<
    [orderHash: BytesLike],
    [MEVResistantDEX.OrderStructOutput],
    "view"
  >;

  getUserNonce: TypedContractMethod<[user: AddressLike], [bigint], "view">;

  orders: TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        boolean,
        boolean,
        bigint
      ] & {
        trader: string;
        tokenIn: string;
        tokenOut: string;
        amountIn: bigint;
        minAmountOut: bigint;
        deadline: bigint;
        salt: bigint;
        commitment: string;
        revealed: boolean;
        executed: boolean;
        commitTimestamp: bigint;
      }
    ],
    "view"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  rescueETH: TypedContractMethod<[to: AddressLike], [void], "nonpayable">;

  rescueTokens: TypedContractMethod<
    [token: AddressLike, to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  revealAndExecute: TypedContractMethod<
    [orderHash: BytesLike, swapRequest: MEVResistantDEX.SwapRequestStruct],
    [void],
    "nonpayable"
  >;

  setPaused: TypedContractMethod<[_paused: boolean], [void], "nonpayable">;

  setRelayerAuthorization: TypedContractMethod<
    [relayer: AddressLike, authorized: boolean],
    [void],
    "nonpayable"
  >;

  uniswapV2Router: TypedContractMethod<[], [string], "view">;

  uniswapV3Router: TypedContractMethod<[], [string], "view">;

  updateDEXRouters: TypedContractMethod<
    [_uniswapV2Router: AddressLike, _uniswapV3Router: AddressLike],
    [void],
    "nonpayable"
  >;

  userNonces: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "COMMIT_REVEAL_DELAY"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "FIXED_FEE_BPS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_SLIPPAGE_BPS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MIN_SLIPPAGE_BPS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "authorizedRelayers"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "canReveal"
  ): TypedContractMethod<[orderHash: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "commitOrder"
  ): TypedContractMethod<[commitment: BytesLike], [void], "payable">;
  getFunction(
    nameOrSignature: "executeOrderByRelayer"
  ): TypedContractMethod<
    [orderHash: BytesLike, swapRequest: MEVResistantDEX.SwapRequestStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getOrder"
  ): TypedContractMethod<
    [orderHash: BytesLike],
    [MEVResistantDEX.OrderStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserNonce"
  ): TypedContractMethod<[user: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "orders"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        boolean,
        boolean,
        bigint
      ] & {
        trader: string;
        tokenIn: string;
        tokenOut: string;
        amountIn: bigint;
        minAmountOut: bigint;
        deadline: bigint;
        salt: bigint;
        commitment: string;
        revealed: boolean;
        executed: boolean;
        commitTimestamp: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "rescueETH"
  ): TypedContractMethod<[to: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "rescueTokens"
  ): TypedContractMethod<
    [token: AddressLike, to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "revealAndExecute"
  ): TypedContractMethod<
    [orderHash: BytesLike, swapRequest: MEVResistantDEX.SwapRequestStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setPaused"
  ): TypedContractMethod<[_paused: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setRelayerAuthorization"
  ): TypedContractMethod<
    [relayer: AddressLike, authorized: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "uniswapV2Router"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "uniswapV3Router"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "updateDEXRouters"
  ): TypedContractMethod<
    [_uniswapV2Router: AddressLike, _uniswapV3Router: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "userNonces"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  getEvent(
    key: "OrderCommitted"
  ): TypedContractEvent<
    OrderCommittedEvent.InputTuple,
    OrderCommittedEvent.OutputTuple,
    OrderCommittedEvent.OutputObject
  >;
  getEvent(
    key: "OrderExecuted"
  ): TypedContractEvent<
    OrderExecutedEvent.InputTuple,
    OrderExecutedEvent.OutputTuple,
    OrderExecutedEvent.OutputObject
  >;
  getEvent(
    key: "OrderRevealed"
  ): TypedContractEvent<
    OrderRevealedEvent.InputTuple,
    OrderRevealedEvent.OutputTuple,
    OrderRevealedEvent.OutputObject
  >;
  getEvent(
    key: "RelayerAuthorized"
  ): TypedContractEvent<
    RelayerAuthorizedEvent.InputTuple,
    RelayerAuthorizedEvent.OutputTuple,
    RelayerAuthorizedEvent.OutputObject
  >;

  filters: {
    "OrderCommitted(bytes32,address,uint256)": TypedContractEvent<
      OrderCommittedEvent.InputTuple,
      OrderCommittedEvent.OutputTuple,
      OrderCommittedEvent.OutputObject
    >;
    OrderCommitted: TypedContractEvent<
      OrderCommittedEvent.InputTuple,
      OrderCommittedEvent.OutputTuple,
      OrderCommittedEvent.OutputObject
    >;

    "OrderExecuted(bytes32,address,uint256,uint256,string)": TypedContractEvent<
      OrderExecutedEvent.InputTuple,
      OrderExecutedEvent.OutputTuple,
      OrderExecutedEvent.OutputObject
    >;
    OrderExecuted: TypedContractEvent<
      OrderExecutedEvent.InputTuple,
      OrderExecutedEvent.OutputTuple,
      OrderExecutedEvent.OutputObject
    >;

    "OrderRevealed(bytes32,address,address,address,uint256,uint256)": TypedContractEvent<
      OrderRevealedEvent.InputTuple,
      OrderRevealedEvent.OutputTuple,
      OrderRevealedEvent.OutputObject
    >;
    OrderRevealed: TypedContractEvent<
      OrderRevealedEvent.InputTuple,
      OrderRevealedEvent.OutputTuple,
      OrderRevealedEvent.OutputObject
    >;

    "RelayerAuthorized(address,bool)": TypedContractEvent<
      RelayerAuthorizedEvent.InputTuple,
      RelayerAuthorizedEvent.OutputTuple,
      RelayerAuthorizedEvent.OutputObject
    >;
    RelayerAuthorized: TypedContractEvent<
      RelayerAuthorizedEvent.InputTuple,
      RelayerAuthorizedEvent.OutputTuple,
      RelayerAuthorizedEvent.OutputObject
    >;
  };
}
